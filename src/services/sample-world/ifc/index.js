// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
var vdl = require('vanadium').vdl;






module.exports = {};



// Types:
var _type1 = new vdl.Type();
var _type2 = new vdl.Type();
var _typeRoboDogStatus = new vdl.Type();
_type1.kind = vdl.kind.LIST;
_type1.name = "";
_type1.elem = vdl.types.BYTE;
_type2.kind = vdl.kind.LIST;
_type2.name = "";
_type2.elem = vdl.types.STRING;
_typeRoboDogStatus.kind = vdl.kind.STRUCT;
_typeRoboDogStatus.name = "services/sample-world/ifc.RoboDogStatus";
_typeRoboDogStatus.fields = [{name: "Name", type: vdl.types.STRING}, {name: "Mood", type: vdl.types.STRING}, {name: "Hunger", type: vdl.types.STRING}, {name: "Eating", type: vdl.types.BOOL}];
_type1.freeze();
_type2.freeze();
_typeRoboDogStatus.freeze();
module.exports.RoboDogStatus = (vdl.registry.lookupOrCreateConstructor(_typeRoboDogStatus));




// Consts:



// Errors:



// Services:

  
    
function Alarm(){}
module.exports.Alarm = Alarm;

    
      
Alarm.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
Alarm.prototype.arm = function(ctx, serverCall) {
  throw new Error('Method Arm not implemented');
};
    
      
Alarm.prototype.delayArm = function(ctx, serverCall, seconds) {
  throw new Error('Method DelayArm not implemented');
};
    
      
Alarm.prototype.unarm = function(ctx, serverCall) {
  throw new Error('Method Unarm not implemented');
};
    
      
Alarm.prototype.panic = function(ctx, serverCall) {
  throw new Error('Method Panic not implemented');
};
     

    
Alarm.prototype._serviceDescription = {
  name: 'Alarm',
  pkgPath: 'services/sample-world/ifc',
  doc: "// Alarm allows clients to manipulate an alarm and query its status.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status returns the current status of the Alarm (i.e., armed, unarmed, panicking).",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Arm',
    doc: "// Arm sets the Alarm to the armed state.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'DelayArm',
    doc: "// DelayArm sets the Alarm to the armed state after the given delay in seconds.",
    inArgs: [{
      name: 'seconds',
      doc: "",
      type: vdl.types.FLOAT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Unarm',
    doc: "// Unarm sets the Alarm to the unarmed state.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Panic',
    doc: "// Panic sets the Alarm to the panicking state.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function LightSwitch(){}
module.exports.LightSwitch = LightSwitch;

    
      
LightSwitch.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
LightSwitch.prototype.flipSwitch = function(ctx, serverCall, toOn) {
  throw new Error('Method FlipSwitch not implemented');
};
     

    
LightSwitch.prototype._serviceDescription = {
  name: 'LightSwitch',
  pkgPath: 'services/sample-world/ifc',
  doc: "// LightSwitch allows clients to manipulate a virtual light switch.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status indicates whether the light is on or off.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'FlipSwitch',
    doc: "// FlipSwitch sets the light to on or off, depending on the input.",
    inArgs: [{
      name: 'toOn',
      doc: "",
      type: vdl.types.BOOL
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function PetFeeder(){}
module.exports.PetFeeder = PetFeeder;

    
      
PetFeeder.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
PetFeeder.prototype.fill = function(ctx, serverCall, amount) {
  throw new Error('Method Fill not implemented');
};
    
      
PetFeeder.prototype.empty = function(ctx, serverCall) {
  throw new Error('Method Empty not implemented');
};
     

    
PetFeeder.prototype._serviceDescription = {
  name: 'PetFeeder',
  pkgPath: 'services/sample-world/ifc',
  doc: "// PetFeeder allows clients to remotely feed their pets.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status returns the current status of the PetFeeder (how full the bowl is).",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.FLOAT64
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Fill',
    doc: "// Fill fills the pet feeder bowl with food. Errors if the bowl will overflow.",
    inArgs: [{
      name: 'amount',
      doc: "",
      type: vdl.types.FLOAT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Empty',
    doc: "// Empty removes all food from the pet feeder bowl.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

  
    
function RoboDog(){}
module.exports.RoboDog = RoboDog;

    
      
RoboDog.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
RoboDog.prototype.speak = function(ctx, serverCall, words) {
  throw new Error('Method Speak not implemented');
};
    
      
RoboDog.prototype.play = function(ctx, serverCall, duration) {
  throw new Error('Method Play not implemented');
};
    
      
RoboDog.prototype.setName = function(ctx, serverCall, name) {
  throw new Error('Method SetName not implemented');
};
     

    
RoboDog.prototype._serviceDescription = {
  name: 'RoboDog',
  pkgPath: 'services/sample-world/ifc',
  doc: "// RoboDog allows clients to play with a virtual robotic dog.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status returns the state of the robotic dog.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: _typeRoboDogStatus
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Speak',
    doc: "// Speak allows a client to speak with the robotic dog.",
    inArgs: [{
      name: 'words',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Play',
    doc: "// Play allows a client to play with the robotic dog.\n// Errors if the dog does not want to play.",
    inArgs: [{
      name: 'duration',
      doc: "",
      type: vdl.types.UINT32
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'SetName',
    doc: "// SetName allows a client to set the robotic dog's name.",
    inArgs: [{
      name: 'name',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function PoolHeater(){}
module.exports.PoolHeater = PoolHeater;

    
      
PoolHeater.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
PoolHeater.prototype.start = function(ctx, serverCall, temperature, duration) {
  throw new Error('Method Start not implemented');
};
    
      
PoolHeater.prototype.stop = function(ctx, serverCall) {
  throw new Error('Method Stop not implemented');
};
     

    
PoolHeater.prototype._serviceDescription = {
  name: 'PoolHeater',
  pkgPath: 'services/sample-world/ifc',
  doc: "// PoolHeater allows clients to control when the pool is being heated.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status retrieves the PoolHeater's status (i.e., active, idle) and temperature.",
    inArgs: [],
    outArgs: [{
      name: 'running',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'temperature',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Start',
    doc: "// Start informs the PoolHeater to heat the pool to the given temperature until the duration expires.",
    inArgs: [{
      name: 'temperature',
      doc: "",
      type: vdl.types.UINT64
    },
    {
      name: 'duration',
      doc: "",
      type: vdl.types.UINT64
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Stop',
    doc: "// Stop informs the PoolHeater to cease heating the pool.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function SmokeDetector(){}
module.exports.SmokeDetector = SmokeDetector;

    
      
SmokeDetector.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
SmokeDetector.prototype.test = function(ctx, serverCall) {
  throw new Error('Method Test not implemented');
};
    
      
SmokeDetector.prototype.sensitivity = function(ctx, serverCall, sens) {
  throw new Error('Method Sensitivity not implemented');
};
     

    
SmokeDetector.prototype._serviceDescription = {
  name: 'SmokeDetector',
  pkgPath: 'services/sample-world/ifc',
  doc: "// SmokeDetector allows clients to monitor and adjust a smoke detector.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status retrieves the current status and sensitivity of the SmokeDetector. ",
    inArgs: [],
    outArgs: [{
      name: 'status',
      doc: "",
      type: vdl.types.STRING
    },
    {
      name: 'sensitivity',
      doc: "",
      type: vdl.types.INT16
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Test',
    doc: "// Test the SmokeDetector to check if it is working.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.BOOL
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Sensitivity',
    doc: "// Sensitivity adjusts the SmokeDetector's sensitivity to smoke.",
    inArgs: [{
      name: 'sens',
      doc: "",
      type: vdl.types.INT16
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function Speaker(){}
module.exports.Speaker = Speaker;

    
      
Speaker.prototype.play = function(ctx, serverCall) {
  throw new Error('Method Play not implemented');
};
    
      
Speaker.prototype.playSong = function(ctx, serverCall, songName) {
  throw new Error('Method PlaySong not implemented');
};
    
      
Speaker.prototype.playStream = function(ctx, serverCall) {
  throw new Error('Method PlayStream not implemented');
};
    
      
Speaker.prototype.getSong = function(ctx, serverCall) {
  throw new Error('Method GetSong not implemented');
};
    
      
Speaker.prototype.pause = function(ctx, serverCall) {
  throw new Error('Method Pause not implemented');
};
    
      
Speaker.prototype.stop = function(ctx, serverCall) {
  throw new Error('Method Stop not implemented');
};
    
      
Speaker.prototype.volume = function(ctx, serverCall, volumeLevel) {
  throw new Error('Method Volume not implemented');
};
    
      
Speaker.prototype.getVolume = function(ctx, serverCall) {
  throw new Error('Method GetVolume not implemented');
};
    
      
Speaker.prototype.addSongs = function(ctx, serverCall, songs) {
  throw new Error('Method AddSongs not implemented');
};
    
      
Speaker.prototype.delete = function(ctx, serverCall, songs) {
  throw new Error('Method Delete not implemented');
};
     

    
Speaker.prototype._serviceDescription = {
  name: 'Speaker',
  pkgPath: 'services/sample-world/ifc',
  doc: "// Speaker allows clients to control the music being played.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Play',
    doc: "// Play starts or continues the current song.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'PlaySong',
    doc: "// PlaySong plays back the given song title, if possible.",
    inArgs: [{
      name: 'songName',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'PlayStream',
    doc: "// PlayStream plays the given stream of music data.",
    inArgs: [],
    outArgs: [],
    inStream: {
      name: '',
      doc: '',
      type: _type1
    },
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'GetSong',
    doc: "// GetSong retrieves the title of the Speaker's current song, if any.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Pause',
    doc: "// Pause playback of the Speaker's current song.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Stop',
    doc: "// Stop playback of the Speaker's current song.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Volume',
    doc: "// Volume adjusts the Speaker's volume.",
    inArgs: [{
      name: 'volumeLevel',
      doc: "",
      type: vdl.types.UINT16
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'GetVolume',
    doc: "// GetVolume retrieves the Speaker's volume.",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.UINT16
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'AddSongs',
    doc: "// AddSongs adds the list of given songs to the song library.",
    inArgs: [{
      name: 'songs',
      doc: "",
      type: _type2
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Delete',
    doc: "// Delete removes the list of given songs from the song library.",
    inArgs: [{
      name: 'songs',
      doc: "",
      type: _type2
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   

  
    
function Sprinkler(){}
module.exports.Sprinkler = Sprinkler;

    
      
Sprinkler.prototype.status = function(ctx, serverCall) {
  throw new Error('Method Status not implemented');
};
    
      
Sprinkler.prototype.start = function(ctx, serverCall, duration) {
  throw new Error('Method Start not implemented');
};
    
      
Sprinkler.prototype.stop = function(ctx, serverCall) {
  throw new Error('Method Stop not implemented');
};
     

    
Sprinkler.prototype._serviceDescription = {
  name: 'Sprinkler',
  pkgPath: 'services/sample-world/ifc',
  doc: "// Sprinkler allows clients to control the virtual sprinkler.",
  embeds: [],
  methods: [
    
      
    {
    name: 'Status',
    doc: "// Status retrieves the Sprinkler's status (i.e., active, idle)",
    inArgs: [],
    outArgs: [{
      name: '',
      doc: "",
      type: vdl.types.STRING
    },
    ],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Start',
    doc: "// Start causes the Sprinkler to emit water for the given duration (in seconds).",
    inArgs: [{
      name: 'duration',
      doc: "",
      type: vdl.types.UINT16
    },
    ],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
    
      
    {
    name: 'Stop',
    doc: "// Stop causes the Sprinkler to cease watering.",
    inArgs: [],
    outArgs: [],
    inStream: null,
    outStream: null,
    tags: []
  },
     
  ]
};

   
 


